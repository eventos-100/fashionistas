are there any other tables that need to be combined or deleted generate report artifcts  create table public.seat_assignments (
  id uuid not null default gen_random_uuid (),
  section_id uuid null,
  registration_id uuid null,
  row_number integer not null,
  seat_number integer not null,
  guest_name text null,
  guest_company text null,
  guest_title text null,
  vip_status text null,
  special_requirements text null,
  checked_in boolean null default false,
  checked_in_at timestamp with time zone null,
  assigned_at timestamp with time zone null default now(),
  assigned_by uuid null,
  organization_id uuid null,
  updated_at timestamp with time zone null default now(),
  constraint seat_assignments_pkey primary key (id),
  constraint seat_assignments_registration_id_key unique (registration_id),
  constraint seat_assignments_section_id_row_number_seat_number_key unique (section_id, row_number, seat_number),
  constraint seat_assignments_section_id_fkey foreign KEY (section_id) references seating_sections (id) on delete CASCADE,
  constraint seat_assignments_registration_id_fkey foreign KEY (registration_id) references registrations (id) on delete CASCADE,
  constraint seat_assignments_organization_id_fkey foreign KEY (organization_id) references organizations (id),
  constraint seat_assignments_assigned_by_fkey foreign KEY (assigned_by) references users (id)
) TABLESPACE pg_default; create table public.seating_sections (
  id uuid not null default gen_random_uuid (),
  event_id uuid null,
  section_name text not null,
  section_code text not null,
  section_type text null,
  row_count integer not null default 1,
  seats_per_row integer not null,
  total_capacity integer GENERATED ALWAYS as ((row_count * seats_per_row)) STORED null,
  priority_level integer null default 0,
  pricing_multiplier numeric null default 1.0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  organization_id uuid null,
  constraint seating_sections_pkey primary key (id),
  constraint seating_sections_event_id_section_code_key unique (event_id, section_code),
  constraint seating_sections_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint seating_sections_organization_id_fkey foreign KEY (organization_id) references organizations (id),
  constraint seating_sections_section_type_check check (
    (
      section_type = any (
        array[
          'front_row'::text,
          'vip'::text,
          'press'::text,
          'buyers'::text,
          'influencers'::text,
          'general'::text
        ]
      )
    )
  )
) TABLESPACE pg_default; create table public.event_communication (
  id uuid not null default gen_random_uuid (),
  event_id uuid null,
  communication_type character varying(50) null,
  message text not null,
  sent_at timestamp with time zone null default now(),
  status character varying(50) null default 'scheduled'::character varying,
  recipient_count integer null default 0,
  delivery_rate numeric(5, 2) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_communication_pkey primary key (id),
  constraint event_communication_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint event_communication_communication_type_check check (
    (
      (communication_type)::text = any (
        (
          array[
            'RSVP'::character varying,
            'reminder'::character varying,
            'edit'::character varying,
            'cancellation'::character varying,
            'notification'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint event_communication_status_check check (
    (
      (status)::text = any (
        (
          array[
            'sent'::character varying,
            'failed'::character varying,
            'scheduled'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_event_communication_event on public.event_communication using btree (event_id) TABLESPACE pg_default;
create index IF not exists idx_event_communication_type on public.event_communication using btree (communication_type) TABLESPACE pg_default;
create index IF not exists idx_event_communication_status on public.event_communication using btree (status) TABLESPACE pg_default;
create trigger update_event_communication_updated_at BEFORE
update on event_communication for EACH row
execute FUNCTION update_updated_at ();  event_communication_view create table public.event_kpis (
  id uuid not null default gen_random_uuid (),
  event_id uuid not null,
  kpi_category text not null,
  kpi_name text not null,
  description text null,
  measurement_unit text not null,
  target_value numeric(12, 2) not null,
  actual_value numeric(12, 2) null,
  achievement_percentage numeric GENERATED ALWAYS as (
    case
      when (target_value = (0)::numeric) then (0)::numeric
      else ((actual_value / target_value) * (100)::numeric)
    end
  ) STORED (5, 2) null,
  performance_status text GENERATED ALWAYS as (
    case
      when (actual_value is null) then 'not_measured'::text
      when (actual_value >= target_value) then 'achieved'::text
      else 'missed'::text
    end
  ) STORED null,
  owner_id uuid null,
  measured_at timestamp with time zone null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_kpis_pkey primary key (id),
  constraint event_kpis_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint event_kpis_owner_id_fkey foreign KEY (owner_id) references users (id),
  constraint event_kpis_kpi_category_check check (
    (
      kpi_category = any (
        array[
          'financial'::text,
          'attendance'::text,
          'engagement'::text,
          'satisfaction'::text,
          'operational'::text,
          'marketing'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_kpis_event on public.event_kpis using btree (event_id) TABLESPACE pg_default;
create index IF not exists idx_kpis_category on public.event_kpis using btree (kpi_category) TABLESPACE pg_default;
create index IF not exists idx_kpis_achievement on public.event_kpis using btree (achievement_percentage desc) TABLESPACE pg_default;
create trigger update_event_kpis_updated_at BEFORE
update on event_kpis for EACH row
execute FUNCTION update_updated_at (); create table public.event_roi (
  id uuid not null default gen_random_uuid (),
  event_id uuid not null,
  ticket_revenue numeric(12, 2) null default 0,
  sponsorship_revenue numeric(12, 2) null default 0,
  vendor_fees numeric(12, 2) null default 0,
  other_revenue numeric(12, 2) null default 0,
  venue_costs numeric(12, 2) null default 0,
  staffing_costs numeric(12, 2) null default 0,
  equipment_costs numeric(12, 2) null default 0,
  marketing_costs numeric(12, 2) null default 0,
  other_costs numeric(12, 2) null default 0,
  actual_attendance integer null,
  calculation_status text null default 'preliminary'::text,
  analysis_notes text null,
  calculated_by uuid null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_roi_pkey primary key (id),
  constraint event_roi_calculated_by_fkey foreign KEY (calculated_by) references users (id),
  constraint event_roi_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE
) TABLESPACE pg_default;
create index IF not exists idx_event_roi_event on public.event_roi using btree (event_id) TABLESPACE pg_default;
create trigger update_event_roi_updated_at BEFORE
update on event_roi for EACH row
create table public.event_reminders (
  id uuid not null default gen_random_uuid (),
  event_id uuid null,
  reminder_type character varying(50) null default 'pre_event'::character varying,
  reminder_time timestamp with time zone not null,
  message text not null,
  reminder_status character varying(50) null default 'scheduled'::character varying,
  target_audience character varying(50) null default 'all'::character varying,
  sent_count integer null default 0,
  success_count integer null default 0,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_reminders_pkey primary key (id),
  constraint event_reminders_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint event_reminders_reminder_status_check check (
    (
      (reminder_status)::text = any (
        (
          array[
            'scheduled'::character varying,
            'sent'::character varying,
            'failed'::character varying,
            'cancelled'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint event_reminders_reminder_type_check check (
    (
      (reminder_type)::text = any (
        (
          array[
            'pre_event'::character varying,
            'post_event'::character varying,
            'rsvp_deadline'::character varying,
            'payment_due'::character varying
          ]
        )::text[]
      )
    )
  ),
  constraint event_reminders_target_audience_check check (
    (
      (target_audience)::text = any (
        (
          array[
            'all'::character varying,
            'confirmed'::character varying,
            'pending'::character varying,
            'vip'::character varying,
            'sponsors'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_event_reminders_event on public.event_reminders using btree (event_id) TABLESPACE pg_default;
create index IF not exists idx_event_reminders_time on public.event_reminders using btree (reminder_time) TABLESPACE pg_default;
create index IF not exists idx_event_reminders_status on public.event_reminders using btree (reminder_status) TABLESPACE pg_default;
create index IF not exists idx_event_reminders_time_status on public.event_reminders using btree (reminder_time, reminder_status) TABLESPACE pg_default;
create trigger update_event_reminders_updated_at BEFORE
update on event_reminders for EACH row
execute FUNCTION update_updated_at ();  execute FUNCTION update_updated_at ();  event_reminders_unified event_reminders_unified event_rsvp_reminders_view create table public.event_rsvp_reminders (
  id uuid not null default gen_random_uuid (),
  event_id uuid null,
  user_id uuid null,
  reminder_type character varying(50) null default 'initial'::character varying,
  reminder_sent boolean null default false,
  reminder_time timestamp with time zone not null,
  sent_time timestamp with time zone null,
  response_received boolean null default false,
  response_time timestamp with time zone null,
  escalation_level integer null default 1,
  template_used character varying(100) null,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_rsvp_reminders_pkey primary key (id),
  constraint event_rsvp_reminders_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint event_rsvp_reminders_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint event_rsvp_reminders_escalation_level_check check (
    (
      (escalation_level >= 1)
      and (escalation_level <= 5)
    )
  ),
  constraint event_rsvp_reminders_reminder_type_check check (
    (
      (reminder_type)::text = any (
        (
          array[
            'initial'::character varying,
            'follow_up'::character varying,
            'final'::character varying,
            'deadline'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_rsvp_reminders_event on public.event_rsvp_reminders using btree (event_id) TABLESPACE pg_default;
create index IF not exists idx_rsvp_reminders_user on public.event_rsvp_reminders using btree (user_id) TABLESPACE pg_default;
create index IF not exists idx_rsvp_reminders_time on public.event_rsvp_reminders using btree (reminder_time) TABLESPACE pg_default;
create index IF not exists idx_rsvp_reminders_sent on public.event_rsvp_reminders using btree (reminder_sent) TABLESPACE pg_default;
create trigger update_event_rsvp_reminders_updated_at BEFORE
update on event_rsvp_reminders for EACH row
execute FUNCTION update_updated_at ();  create table public.event_sponsors (
  id uuid not null default gen_random_uuid (),
  event_id uuid not null,
  sponsor_id uuid not null,
  sponsorship_tier text not null,
  sponsorship_amount numeric(12, 2) not null default 0,
  in_kind_value numeric(12, 2) null default 0,
  payment_status text null default 'pending'::text,
  amount_paid numeric(12, 2) null default 0,
  payment_due_date date null,
  benefits jsonb null default '{}'::jsonb,
  booth_number text null,
  booth_size text null,
  logo_placements text[] null default '{}'::text[],
  speaking_slots integer null default 0,
  complimentary_tickets integer null default 0,
  discount_percentage numeric(5, 2) null default 0,
  contract_status text null default 'draft'::text,
  contract_signed_date date null,
  contract_url text null,
  booth_visitors integer null default 0,
  leads_collected integer null default 0,
  roi_percentage numeric(8, 2) null,
  satisfaction_score integer null,
  testimonial text null,
  metadata jsonb null default '{}'::jsonb,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  constraint event_sponsors_pkey primary key (id),
  constraint event_sponsors_event_id_sponsor_id_key unique (event_id, sponsor_id),
  constraint event_sponsors_sponsor_id_fkey foreign KEY (sponsor_id) references sponsors (id) on delete CASCADE,
  constraint event_sponsors_event_id_fkey foreign KEY (event_id) references events (id) on delete CASCADE,
  constraint event_sponsors_sponsorship_tier_check check (
    (
      sponsorship_tier = any (
        array[
          'title'::text,
          'platinum'::text,
          'gold'::text,
          'silver'::text,
          'bronze'::text,
          'media'::text,
          'in-kind'::text
        ]
      )
    )
  ),
  constraint event_sponsors_payment_status_check check (
    (
      payment_status = any (
        array[
          'pending'::text,
          'partial'::text,
          'paid'::text,
          'overdue'::text
        ]
      )
    )
  ),
  constraint event_sponsors_satisfaction_score_check check (
    (
      (satisfaction_score >= 1)
      and (satisfaction_score <= 10)
    )
  ),
  constraint event_sponsors_contract_status_check check (
    (
      contract_status = any (
        array[
          'draft'::text,
          'sent'::text,
          'signed'::text,
          'expired'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_event_sponsors_event on public.event_sponsors using btree (event_id) TABLESPACE pg_default;
create index IF not exists idx_event_sponsors_sponsor on public.event_sponsors using btree (sponsor_id) TABLESPACE pg_default;
create trigger update_event_sponsors_updated_at BEFORE
update on event_sponsors for EACH row
execute FUNCTION update_updated_at (); create table public.organizations (
  id uuid not null default gen_random_uuid (),
  name text not null,
  slug text not null,
  email text not null,
  phone character varying(20) not null,
  business_type text null default 'company'::text,
  address_line1 text not null,
  address_line2 text null,
  city text not null,
  province text not null,
  postal_code text not null,
  country text null default 'Canada'::text,
  subscription_tier text null default 'free'::text,
  subscription_status text null default 'active'::text,
  timezone text null default 'America/Toronto'::text,
  currency character varying(3) null default 'CAD'::character varying,
  metadata jsonb null default '{}'::jsonb,
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  is_deleted boolean null default false,
  deleted_at timestamp with time zone null,
  deleted_by uuid null,
  constraint organizations_pkey primary key (id),
  constraint organizations_slug_key unique (slug),
  constraint organizations_deleted_by_fkey foreign KEY (deleted_by) references users (id)
) TABLESPACE pg_default;
create index IF not exists idx_organizations_not_deleted on public.organizations using btree (id) TABLESPACE pg_default
where
  (is_deleted = false);
create trigger update_organizations_updated_at BEFORE
update on organizations for EACH row
execute FUNCTION update_updated_at (); create table public.user_organizations (
  id uuid not null default gen_random_uuid (),
  user_id uuid null,
  organization_id uuid null,
  role text not null default 'member'::text,
  permissions jsonb null default '{}'::jsonb,
  is_active boolean null default true,
  joined_at timestamp with time zone null default now(),
  created_at timestamp with time zone null default now(),
  updated_at timestamp with time zone null default now(),
  display_name text null,
  description text null,
  category text null,
  type_name text null,
  type_slug text null,
  legacy_role_id uuid null,
  legacy_type_id uuid null,
  permissions_json jsonb null default '{}'::jsonb,
  constraint user_organizations_pkey primary key (id),
  constraint user_organizations_user_id_organization_id_key unique (user_id, organization_id),
  constraint user_organizations_organization_id_fkey foreign KEY (organization_id) references organizations (id) on delete CASCADE,
  constraint user_organizations_user_id_fkey foreign KEY (user_id) references users (id) on delete CASCADE,
  constraint user_organizations_category_check check (
    (
      category = any (
        array[
          'event_management'::text,
          'fashion'::text,
          'media'::text,
          'general'::text
        ]
      )
    )
  ),
  constraint user_organizations_role_check check (
    (
      role = any (
        array[
          'owner'::text,
          'admin'::text,
          'member'::text,
          'viewer'::text
        ]
      )
    )
  )
) TABLESPACE pg_default;
create index IF not exists idx_user_organizations_user on public.user_organizations using btree (user_id) TABLESPACE pg_default;
create index IF not exists idx_user_organizations_org on public.user_organizations using btree (organization_id) TABLESPACE pg_default;
create index IF not exists idx_user_org_legacy_type on public.user_organizations using btree (legacy_type_id) TABLESPACE pg_default
where
  (legacy_type_id is not null);
create index IF not exists idx_user_org_legacy_role on public.user_organizations using btree (legacy_role_id) TABLESPACE pg_default
where
  (legacy_role_id is not null);
create index IF not exists idx_user_org_type_slug on public.user_organizations using btree (type_slug) TABLESPACE pg_default
where
  (type_slug is not null);
create index IF not exists idx_user_org_permissions_gin on public.user_organizations using gin (permissions) TABLESPACE pg_default;
create index IF not exists idx_user_org_category on public.user_organizations using btree (category) TABLESPACE pg_default;
create index IF not exists idx_user_org_permissions_json_gin on public.user_organizations using gin (permissions_json) TABLESPACE pg_default;
create trigger update_user_organizations_updated_at BEFORE
update on user_organizations for EACH row
execute FUNCTION update_updated_at ();
