## Understanding Agentic Frameworks: A Deep Dive into Ava's Brain

### Introduction

In this lesson, we explore the intricacies of building agentic systems, specifically focusing on Ava, a WhatsApp agent. The session is structured around understanding the frameworks that support these systems, dissecting Ava's architecture, and setting up the necessary tools for development. This summary encapsulates the key points discussed, providing a comprehensive overview of the concepts and practical applications involved in creating intelligent agents.

---

### Key Concepts of Agentic Frameworks

1. **Definition of Agentic Systems**:  
     
   - An agentic system is a framework that allows for the creation of intelligent agents capable of autonomous decision-making.  
   - The focus is on understanding the architecture and functionality of these systems rather than debating the authenticity of AI agents.

   

2. **Framework Options**:  
     
   - **Low Code/No Code Tools**:  
     - Examples: n8n, Flowise  
     - **Pros**: User-friendly, drag-and-drop interfaces.  
     - **Cons**: Limited by available integrations and less control over the underlying code.  
   - **Code Frameworks**:  
     - Examples: Langra, Llama Index  
     - **Pros**: Greater control and flexibility in building complex systems.  
     - **Cons**: Requires coding knowledge and experience.

   

3. **Choosing the Right Framework**:  
     
   - The choice between low code and code frameworks hinges on the level of control desired.  
   - Langra is favored for its low-level access and intuitive graph architecture, allowing for robust and flexible agent design.

---

### Dissecting Ava's Brain

Ava's architecture is represented as a graph, consisting of nodes and edges that define its functionality. The following components are crucial to understanding how Ava operates:

| Component | Function |
| :---- | :---- |
| **Memory Structure** | Extracts key information from user messages for long-term memory storage. |
| **Router Node** | Determines the flow of the application, deciding how Ava responds (text, audio, image). |
| **Context Injection** | Injects relevant context and memory into conversations, enhancing user interaction. |
| **Inference Providers** | Utilizes different models for generating responses based on the type of interaction. |

#### Stateful Graph

- Ava's brain is described as a **stateful graph**, meaning it maintains a state that tracks information across nodes.  
- This state management is essential for providing contextually relevant responses and maintaining conversation history.

---

### Code Overview

The code structure for Ava's brain is organized into modules that represent different functionalities:

1. **Nodes**:  
     
   - Each node corresponds to a specific function (e.g., generating audio, summarizing conversations).  
   - Functions are designed to modify the state based on user interactions.

   

2. **State Management**:  
     
   - The state class inherits from a base class, allowing it to store conversation history and relevant parameters.  
   - Key parameters include:  
     - Summary of the conversation  
     - Current activity  
     - Memory context

   

3. **Graph and Edges**:  
     
   - The graph is constructed by connecting nodes through edges, defining the flow of information.  
   - The compilation of the graph is necessary for execution, ensuring that all nodes and edges are properly linked.

---

### Setting Up Langra Studio

Langra Studio is a powerful tool for running and debugging Ava's agentic system. Key features include:

- **Execution of Graphs**: Users can run the graph with specific states, allowing for real-time interaction and testing.  
- **Debugging Capabilities**: Inspecting the flow of information and understanding how different nodes interact is facilitated through the studio.  
- **Setup Process**:  
  - Install necessary packages and dependencies.  
  - Compile the graph and set up environment variables for API access.

---

### Practical Applications of Agentic Systems

The knowledge gained from this lesson can be applied to various real-world scenarios, including:

- **Automated Appointment Scheduling**: Using WhatsApp to manage appointments seamlessly.  
- **Customer Support Agents**: Integrating with databases to provide real-time assistance and manage inquiries.  
- **Financial Advisory Services**: Utilizing APIs to deliver market updates and financial advice.  
- **Healthcare Reminders**: Sending automated reminders to patients for medication or appointments.

---

### Conclusion

In summary, this lesson provided a comprehensive understanding of agentic frameworks, focusing on Ava's architecture and the tools necessary for development. By dissecting Ava's brain, we gained insights into the functionality of nodes, state management, and the importance of choosing the right framework. The practical applications discussed highlight the potential of agentic systems in various industries, paving the way for innovative solutions that enhance user interaction and automate processes. As we continue to explore these concepts, we encourage feedback and questions to tailor future lessons to the audience's needs.

---

This summary encapsulates the essence of the lesson while adhering to the specified structure and word count. The use of lists, tables, and formatting enhances readability and comprehension, making it a valuable resource for understanding agentic systems.

you want to see something cool this is where AA was created here we have her mind fluid imperfect patterned chaotic okay first of all how cool was that intro and did notice that Oscar isak's character wasn't really looking like him or is it maybe that we already look very similar in that movie well if you want to know how I did that so how I swap faces both in images and in videos just let me know in the comments and I can do a video about that I think it's really cool but enough with face swapping for this video let's let's get started with this lesson so welcome to lesson two of this curse ABA the WhatsApp agent in today's video we're going to cover two things at first we're going to understand what are these Frameworks for agentic systems or these agentic Frameworks and I'm going to explain you here why we chose to build Ava using langra and then when that's clear we're going to dissect aa's brain and we are going to dissect it by doing three things by looking at this diagram that Miguel has prepared by doing a code overview I'm going to show you all the important parts um that build avas brain in code so I'm we're going to be looking at that as well and finally at the end of this video I'm going to show you how you can set up lra studio so that you can run and debug your agent graph which actually looks like this so in lesson one we already Define what an AI agent is and actually we concluded that we shouldn't really be talking about what is a true AI agent we should be thinking about agentic system and now for building this kind of agentic systems you have different options or different Frameworks and I think the first distinction that we have to make is between low code or no code tools like n8n or flow wise and code Frameworks like langra or the new a small agent from haging face and I think the key difference between these two groups boils down to one world which is control because when you have access to the code to everything that your agent or your identic system is doing you can potentially build anything that you want well that is if you can code it of course but don't get me wrong I think this low code applications are becoming very very powerful I've personally seen not build but seen a lot of amazing applications built especially on n8n which is this kind of graph based or node based architecture that you can just drag and drop and just connect different things but as I said you are limited by the integration so you have plenty but yeah you depend on them implementing an integration for you though I believe as well that you can inject code so you really can do a lot of things but again it's just not the same as having complete control over the code then you also have flow wise and ribet which I think allows for a lot of code injection so this I think this they come they come as this low code more than no code and then you have make which I think doesn't get to the level of n88 in terms of yeah complex the workflows that you can build or the automations that you can build are I don't think you can create cycles for example so I think make is more like an automation platform more than kind of like an agentic and then on the other side we have the code Frameworks and here among on this two we have the ones that like lra or Qi and pantic for example that allows for a lot of control as well for you to really control every single part of the application or or then you also have other Frameworks that have more as abstraction like like Lan chain or Lama index I personally haven't used them all and I think you shouldn't use the mode I think you should just choose one that you feel that adapts better to your workflow and the way that you work and just commit to it and work on it and I encourage you that if you are already a coder or if you are not afraid of learning how to code you should go for a coding framework okay now among all these Frameworks why we chose lra and again I think it comes back to the same word to control right and what I mean by control is that lra allows you to really go low level and it removes all these abstractions that for example L chain has but as I have here I think also the the way the way that is architected as a graph I think makes a lot of sense and even though we go low level I think it is still intuitive to understand what is happening in the system another good point for for me was that of course it integrates nicely with L chain because they come from the same company and I am already a fan of L chain and what I really like about L chain is just that is platform agnostic right that I can easily just use this inference provider work Gro like we use here but just change it and now use anthropic or open AI or azour so the one that I really prefer and finally as a robust really framework that it is it allows you to to have streaming parallelization of different workflows readymade integration just to make it easier for you and also multi-agents now let's put the focus back on abas or on abas brain and let's pay attention to what I have here which is the title of this lesson abas brain is graph or as M likes to put it abas brain is youra Lang graph but also added an asterisk here which is down here a stateful graph and I'm going to explain you just in a couple of seconds what is this but let us first look at this beautiful diagram that Miguel has prepared oh and by the way if you want to get the content from this lesson in written form you also have a link to Miguel's news letter Down Below in the description box and now coming back to the diagram so what we have here are different notes and edges so that is a graph right and let's review now all these notes or the most important ones so then later when we go to the code we understand it even better so starting from the top we have the memory struction so this node what it does is to understand from the message of the user if there is a key piece of information that should be remember so that should be put into the long-term memory then we have the router node so the router was one of these agentic patterns and what it does is to Route uh the the flow of the application so what is the next node that should be executed so that's what we have here as select workflows right so our router node what it does is just what it does is just that AA would decide autonomously how she will answer to us will she answer with a voice note will she answer with a text or will she answer with an image Noe so that will depend on the kind of or the flow of the conversation right so it will depend on her and we also have another things for example we have a note to inject context and to inject memory so that is for example avas activities because AA has a daily schedule and also inject those memories that could be key to form an answer and finally once one of these audio text or image notes are executed H each one with their pertaining um inference provider right if it's an audio node we are going to need to generate the audio with the level UPS if it's text we just directly run Lama 3.3 and if it's an image node we will generate an image using together sayi flax endpoint and finally we will summarize the conversation so that Ava can handle the context better and now before we start looking at the code let's understand this whole stateful term so as we said AAS brain is just a graph right so as with any graph um is composed by nodes and edges but here in the case of of lra we also have a state and is this a state the one that handles all the information that is being shared and populated in all these different nodes and this is going to make much more sense once we look the code I promise so let's let's do that so now how is everything that we have discussed uh reflected now in code well let me tell you I think it's quite straightforward and probably even simple to understand so let's pay attention to the module graph that we have within the AI companion uh directory which by the way if you don't know this um this whole course is open source and it's free of course and you have the link down below to to this GitHub repo so yeah go ahead and clone the repo if you want to follow this whole thing in your own ID so here in the module graph now we have different files for the edges the nodes the graph and the state so let's have a look at those so let's start by looking at the nodes and what we have here are different functions that would represent each node and in each function you should be looking at two things actually first of all at the parameter that each function has the state we're going to be looking at the state just in a couple of seconds but we have just our own panti class the AI companion state right or avas state and also the return type so what we have is a dictionary and this dictionary is the one that is going to be modifying the state again you will understand just in a couple of seconds once we look at the state and here we have all those notes that we commented before right so the image node would be the one that would create an image and it would answer H depending on on just the whole conversation we also have the audio that would use use 11 labs and we have the summarized conversation the memory exraction so we have it all and you should have a look at The Code by yourself and just understand it dig deep just get and and understand every function but I think in this video maybe we can look at the router note which is just the one that I mentioned before right this identic pattern that what it does is just to to determine what to do right so it determines the flow of the application and what we have is actually something very very simple so we actually have just a couple of lines of of code and what we do is we build a chain and we build this Chain by just using a prom that I will show you in a second with the ex structor output right so this and and that output is going to be this class the router response which which we have over here and this indicates the model how to resp so what we have is the response type which already the name kind of tells what it is right which kind of response should ABA give and we give a description just telling what it is to the model and this works well because we have the router prompt and this is just a router prom that you should have a look at it by yourself but essentially what we do is just to really explain to her all the rules for her to understand when when it should be an image generation when it should be an audio and what are the general the general rules so I'm not going to read this whole prom right now you have um you have it by yourself you can really look at it and understand why we have done all these things and now coming back to the node function right so we have created that chain that uses the prompt and that strict our output so now we have to invoke that chain right with this invoke asynchronous invoke a function that gets us the answer and it is this answer now that we are going to kind of like plug into the estate by using this right by returning this workflow right because now their workflow is one parameter of the estate and let's have a look at the state class right now and what we have is just a python class uh that inherits from another class which is the message messages State class which allows us to really try the conversation history and also keep that last message that we receive but essentially use a python class you set up the arguments or the parameters that you want to be storing and that you want to be saving and those for us are these ones right so we have the summary of the conversation the workflow so this is just what we have done here right we decide the workflow based on the router prompt so we keep that now in the state same thing also for the audio buff the image path the current activity and and the memory and another note that I want to show you in this video is this context injection note that injects the context of aa's current activity and I think this note is quite special because I think this is part of what makes AA just act so humanik because she has an activity she so AA has a schedule and and we can we can have a look at it and you can have a look at the The Code by yourself but essentially what we have is just kind of like time frame things or that that she's going to do right for example she starts a peaceful morning review in personal machine learning project results right so and also part of aa's personality is that she is also a machine learning engineer like Miguel and I and this is really cool because now Miguel and I we can both talk with ABA about machine Learning Without boring her so those would be two of the notes that we have built but as as I said code this open source just dig deep into it understand each note by yourself you're going to really see how everything makes sense due to this graph architecture okay so we have seen notes and the state let's have a look now at the graph and the edges so we have just a bit more kind of like complex edges so this would be conversational edges we will see that later and we have the graph and it is here in this H file where we put together nodes and edges and we do that by using the class um State graph H which uses our um our state and then what we do is just to start adding those nodes and then we connect those nodes via edges right so we have the kind of like the the start node that then goes to the memory extraction node and then we have the memory extraction note that goes to the WR or no and we continue to do that until we have the final graph build build and the last important element of L graph that you should understand is the compilation so once you have that graph built you have to compile it and you can compile it using a checkpoint which actually has a checkpoint of uh the state and this is what we call the shortterm memory that we Implement via SQL L and we are going to explain you this better in the next lesson along with the long-term memory that we Implement using quadrant and finally to finish up with this video and as promised in the intro let's have a look at langra studio so langra studio is a very powerful app that allows you to take your graph or your agentic system that is a graph and allows you to run it with the state that you want to put so you can just change anything from the state for example the a message we can put something about um what's my favorite movie and we can execute this by just clicking submit or just creating clicking command enter and this is going to execute the graph as it does really right and here for example we have seen that for giving us an answer it went on and use the conversation Noe right so the previous note was the memory injection and the next one is the summary conversation note and for example we can see here the answer from her which is X minina right because this is something that I have told her um in previous conversation so she knows that right so H look at this for example this is the memory context so and by using the long-term memory we have extracted that I have already told her that my favorite movie is X minina also somehow Pizza is semantic semantically similar to movies also I don't have that many um so that many records in the longterm memory but yeah this is all we'll be explained in the next lesson so really subscribe if you haven't because I think it's going to be a really good one but yeah it not only allows you to run the graph it also allows you to debug it or to inspect it right we can see for example what was the result of the context injection right we have for example got that the current activity is that an evening routine while catching up on NASA's latest exoplanet discoveries right so this is AAS activities right and then we can see how the router the output of the router was conversation right so that was what we so for the response type is conversation and yeah this is truly truly powerful you can even rerun uh from different parts of the of the graph you can even change the state or understand the state rerun it from that part and then you see right so you can change something about the about the memory context just something about the state and rerun it from that point so extremely extremely powerful for you to debug your applications and how do you set this up you might ask so it is quite simple so they have this article that explains you very very simple so you have two ways so you can you could use the langra desktop app that for me was causing a lot of error so I actually went and used the development server and the only thing that you have to do is to pep install um this package or in my case via UV so UV pep install this package and then just launching it with lra so if we open cursor we see here that I just run this so by just running that it directly opens up langra Studio oh and something else that you got to have is just in your project directory you got to have two things so one you got to have your uh graph already compiled and you got to have this in a in a independent variable so that you can then take it using the Lang graph. Json so you need this file and in this file you have to set up the dependencies so this would be all the dependencies so this will take the um the PIP project to with all the dependencies and then you have to point at the agent or the agent so you might have even more than one agent so here we point at it right and you also use your M file so that it takes all your environment variables for example your Gro API key to be able to run inference using Lama 3.3 and that concluded lesson two of ABA the WhatsApp agent and I really hope you got a base understanding of how langra works but if you did please write me a comment in the comment section below with just anything that wasn't clear or just any questions that you might have and if you go to this part of the video I would actually appreciate if you can just tell me a little bit about yourself so about how much experience do you have with python with programming with artificial intelligence so that I know more or less who is watching these videos and and then I just tailor the next lessons to you also I'm going to put like always links to all the relevant information and something that I think is really amazing is just lra Academy has a free course on langra that is really really good I I did it myself and I actually recommend it and finally I want you to to understand that what you have learned today with langra and these kind of ageny Frameworks allows you to build very very powerful real world application so um AA so far is just kind of like a sophisticated um conversational machine right she's able let's say to pass the tting test she really acts humanly but maybe this doesn't have those real war implications so you can really think and build um those applications right so think about for example um an automated appoint appointment setting right so you via WhatsApp you can set confirm and reschedule just dates that you have in your business or um or business that you maybe you want to sell this service to maybe like a personal assistance or maybe like in the movie here you can have a system like Samantha that manages your calendar the emails tells you about the weather and everything could be conversational in WhatsApp more things you could even have maybe like a customer support agent that is connected via a database tool to your database and then it tracks the orders and maybe manages returns and more and more so think about a financial advisor so there are different API keys so apis that connect to maybe like the Yahoo finance API that connects to the market I you can get Market updates also you could use x AI AP ke so you can get real um real time information about what is happening in Twitter or in X and then maybe this can tell you about the market and think about Healthcare as well so you can have um a conversational WhatsApp agent that maybe sends reminders to to patients or maybe like in case of urgency it acts right it does something and you can build these applications by just writing the specific tools for this kind of use cases and just give that to the agent and that's it it's just notes edges and estate and we have learned that today well that that really was all for lesson two I'll see you in the next lesson byebye  
